module.exports = {"http://datashapes.org/js/dash.js":"// Functions implementing the validators of SHACL-JS\n// Also include validators for the constraint components of the DASH namespace\n\n// Also included: implementations of the standard DASH functions\n\n// There is no validator for sh:property as this is expected to be\n// natively implemented by the surrounding engine.\n\nvar XSDIntegerTypes = new NodeSet();\nXSDIntegerTypes.add(T(\"xsd:integer\"));\n\nvar XSDDecimalTypes = new NodeSet();\nXSDDecimalTypes.addAll(XSDIntegerTypes.toArray());\nXSDDecimalTypes.add(T(\"xsd:decimal\"));\nXSDDecimalTypes.add(T(\"xsd:float\"));\n\nfunction validateAnd($value, $and) {\n\tvar shapes = new RDFQueryUtil($shapes).rdfListToArray($and);\n\tfor(var i = 0; i < shapes.length; i++) {\n\t\tif(!SHACL.nodeConformsToShape($value, shapes[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction validateClass($value, $class) {\n\treturn new RDFQueryUtil($data).isInstanceOf($value, $class);\n}\n\nfunction validateClosed($value, $closed, $ignoredProperties, $currentShape) {\n\tif(!T(\"true\").equals($closed)) {\n\t\treturn;\n\t}\n\tvar allowed = $shapes.query().\n\t\tmatch($currentShape, \"sh:property\", \"?propertyShape\").\n\t\tmatch(\"?propertyShape\", \"sh:path\", \"?path\").\n\t\tfilter(function(solution) { return solution.path.isURI() } ).\n\t\tgetNodeSet(\"?path\");\n\tif($ignoredProperties) {\n\t\tallowed.addAll(new RDFQueryUtil($shapes).rdfListToArray($ignoredProperties));\n\t}\n\tvar results = [];\n\t$data.query().\n\t\tmatch($value, \"?predicate\", \"?object\").\n\t\tfilter(function(sol) { return !allowed.contains(sol.predicate)}).\n\t\tforEach(function(sol) { \n\t\t\tresults.push({ \n\t\t\t\tpath : sol.predicate,\n\t\t\t\tvalue : sol.object\n\t\t\t});\n\t\t});\n\treturn results;\n}\n\nfunction validateClosedByTypesNode($this, $closedByTypes) {\n\tif(!T(\"true\").equals($closedByTypes)) {\n\t\treturn;\n\t}\n\tvar results = [];\n\tvar allowedProperties = new NodeSet();\n\t$data.query().\n\t\tmatch($this, \"rdf:type\", \"?directType\").\n\t\tpath(\"?directType\", { zeroOrMore : T(\"rdfs:subClassOf\") }, \"?type\").\n\t\tforEachNode(\"?type\", function(type) {\n\t\t\t$shapes.query().\n\t\t\t\tmatch(type, \"sh:property\", \"?pshape\").\n\t\t\t\tmatch(\"?pshape\", \"sh:path\", \"?path\").\n\t\t\t\tfilter(function(sol) { return sol.path.isURI() }).\n\t\t\t\taddAllNodes(\"?path\", allowedProperties);\n\t\t});\n\t$data.query().\n\t\tmatch($this, \"?predicate\", \"?object\").\n\t\tfilter(function(sol) { return !T(\"rdf:type\").equals(sol.predicate) }).\n\t\tfilter(function(sol) { return !allowedProperties.contains(sol.predicate) }).\n\t\tforEach(function(sol) {\n\t\t\tresults.push({\n\t\t\t\tpath: sol.predicate,\n\t\t\t\tvalue: sol.object\n\t\t\t});\n\t\t})\n\treturn results;\n}\n\nfunction validateCoExistsWith($this, $path, $coExistsWith) {\n\tvar path = toRDFQueryPath($path);\n\tvar has1 = $data.query().path($this, path, null).getCount() > 0;\n\tvar has2 = $data.query().match($this, $coExistsWith, null).getCount() > 0;\n\treturn has1 == has2;\n}\n\nfunction validateDatatype($value, $datatype) {\n\tif($value.isLiteral()) {\n\t\treturn $datatype.equals($value.datatype) && isValidForDatatype($value.lex, $datatype);\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\nfunction validateDisjoint($this, $value, $disjoint) {\n\treturn !$data.query().match($this, $disjoint, $value).hasSolution();\n}\n\nfunction validateEqualsProperty($this, $path, $equals) {\n\tvar results = [];\n\tvar path = toRDFQueryPath($path);\n\t$data.query().path($this, path, \"?value\").forEach(\n\t\tfunction(solution) {\n\t\t\tif(!$data.query().match($this, $equals, solution.value).hasSolution()) {\n\t\t\t\tresults.push({\n\t\t\t\t\tvalue: solution.value\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t$data.query().match($this, $equals, \"?value\").forEach(\n\t\tfunction(solution) {\n\t\t\tif(!$data.query().path($this, path, solution.value).hasSolution()) {\n\t\t\t\tresults.push({\n\t\t\t\t\tvalue: solution.value\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\treturn results;\n}\n\nvar validateEqualsNode = function ($this, $equals) {\n    var results = [];\n    var solutions = 0;\n    $data.query().path($this, $equals, \"?value\").forEach(\n        function (solution) {\n            solutions++;\n            if (SHACL.compareNodes($this, solution['value']) !== 0) {\n                results.push({\n                    value: solution.value\n                });\n            }\n        });\n    if (results.length === 0 && solutions === 0) {\n        results.push({\n            value: $this.value\n        });\n    }\n    return results;\n};\n\nfunction validateHasValueNode($this, $hasValue) {\n\treturn $this.equals($hasValue);\n}\n\nfunction validateHasValueProperty($this, $path, $hasValue) {\n\tvar count = $data.query().path($this, toRDFQueryPath($path), $hasValue).getCount();\n\treturn count > 0;\n}\n\nfunction validateHasValueWithClass($this, $path, $hasValueWithClass) {\n\treturn $data.query().\n\t\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\t\tfilter(function(sol) { return new RDFQueryUtil($data).isInstanceOf(sol.value, $hasValueWithClass) }).\n\t\t\thasSolution();\n}\n\nfunction validateIn($value, $in) {\n\tvar set = new NodeSet();\n\tset.addAll(new RDFQueryUtil($shapes).rdfListToArray($in));\n\treturn set.contains($value);\n}\n\nfunction validateLanguageIn($value, $languageIn) {\n\tif(!$value.isLiteral()) {\n\t\treturn false;\n\t}\n\tvar lang = $value.language;\n\tif(!lang || lang === \"\") {\n\t\treturn false;\n\t}\n\tvar ls = new RDFQueryUtil($shapes).rdfListToArray($languageIn);\n\tfor(var i = 0; i < ls.length; i++) {\n\t\tif(lang.startsWith(ls[i].lex)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction validateLessThanProperty($this, $path, $lessThan) {\n\tvar results = [];\n\t$data.query().\n\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\tmatch($this, $lessThan, \"?otherValue\").\n\t\tforEach(function(sol) {\n\t\t\t\t\tvar c = SHACL.compareNodes(sol.value, sol.otherValue);\n\t\t\t\t\tif(c == null || c >= 0) {\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tvalue: sol.value\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\treturn results;\n}\n\nfunction validateLessThanOrEqualsProperty($this, $path, $lessThanOrEquals) {\n\tvar results = [];\n\t$data.query().\n\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\tmatch($this, $lessThanOrEquals, \"?otherValue\").\n\t\tforEach(function(sol) {\n\t\t\t\t\tvar c = SHACL.compareNodes(sol.value, sol.otherValue);\n\t\t\t\t\tif(c == null || c > 0) {\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tvalue: sol.value\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\treturn results;\n}\n\nfunction validateMaxCountProperty($this, $path, $maxCount) {\n\tvar count = $data.query().path($this, toRDFQueryPath($path), \"?any\").getCount();\n\treturn count <= Number($maxCount.value);\n}\n\nfunction validateMaxExclusive($value, $maxExclusive) {\n\treturn $value.isLiteral() && Number($value.lex) < Number($maxExclusive.lex);\n}\n\nfunction validateMaxInclusive($value, $maxInclusive) {\n\treturn $value.isLiteral() && Number($value.lex) <= Number($maxInclusive.lex);\n}\n\nfunction validateMaxLength($value, $maxLength) {\n\tif($value.isBlankNode()) {\n\t\treturn false;\n\t}\n\treturn $value.value.length <= Number($maxLength.lex);\n}\n\nfunction validateMinCountProperty($this, $path, $minCount) {\n\tvar count = $data.query().path($this, toRDFQueryPath($path), \"?any\").getCount();\n\treturn count >= Number($minCount.value);\n}\n\nfunction validateMinExclusive($value, $minExclusive) {\n\treturn $value.isLiteral() && Number($value.lex) > Number($minExclusive.lex);\n}\n\nfunction validateMinInclusive($value, $minInclusive) {\n\treturn $value.isLiteral() && Number($value.lex) >= Number($minInclusive.lex);\n}\n\nfunction validateMinLength($value, $minLength) {\n\tif($value.isBlankNode()) {\n\t\treturn false;\n\t}\n\treturn $value.value.length >= Number($minLength.lex);\n}\n\nfunction validateNodeKind($value, $nodeKind) {\n\tif($value.isBlankNode()) {\n\t\treturn T(\"sh:BlankNode\").equals($nodeKind) || \n\t\t\tT(\"sh:BlankNodeOrIRI\").equals($nodeKind) ||\n\t\t\tT(\"sh:BlankNodeOrLiteral\").equals($nodeKind);\n\t}\n\telse if($value.isURI()) {\n\t\treturn T(\"sh:IRI\").equals($nodeKind) || \n\t\t\tT(\"sh:BlankNodeOrIRI\").equals($nodeKind) ||\n\t\t\tT(\"sh:IRIOrLiteral\").equals($nodeKind);\n\t}\n\telse if($value.isLiteral()) {\n\t\treturn T(\"sh:Literal\").equals($nodeKind) || \n\t\t\tT(\"sh:BlankNodeOrLiteral\").equals($nodeKind) ||\n\t\t\tT(\"sh:IRIOrLiteral\").equals($nodeKind);\n\t}\n}\n\nfunction validateNode($value, $node) {\n\treturn SHACL.nodeConformsToShape($value, $node);\n}\n\nfunction validateNonRecursiveProperty($this, $path, $nonRecursive) {\n\tif(T(\"true\").equals($nonRecursive)) {\n\t\tif($data.query().path($this, toRDFQueryPath($path), $this).hasSolution()) {\n\t\t\treturn {\n\t\t\t\tpath: $path,\n\t\t\t\tvalue: $this\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction validateNot($value, $not) {\n\treturn !SHACL.nodeConformsToShape($value, $not);\n}\n\nfunction validateOr($value, $or) {\n\tvar shapes = new RDFQueryUtil($shapes).rdfListToArray($or);\n\tfor(var i = 0; i < shapes.length; i++) {\n\t\tif(SHACL.nodeConformsToShape($value, shapes[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction validatePattern($value, $pattern, $flags) {\n\tif($value.isBlankNode()) {\n\t\treturn false;\n\t}\n\tvar re = $flags ? new RegExp($pattern.lex, $flags.lex) : new RegExp($pattern.lex);\n\treturn re.test($value.value);\n}\n\nfunction validatePrimaryKeyProperty($this, $path, $uriStart) {\n\tif(!$this.isURI()) {\n\t\treturn \"Must be an IRI\";\n\t}\n\tif($data.query().path($this, toRDFQueryPath($path), null).getCount() != 1) {\n\t\treturn \"Must have exactly one value\";\n\t}\n\tvar value = $data.query().path($this, toRDFQueryPath($path), \"?value\").getNode(\"?value\");\n\tvar uri = $uriStart.lex + encodeURIComponent(value.value);\n\tif(!$this.uri.equals(uri)) {\n\t\treturn \"Does not have URI \" + uri;\n\t}\n}\n\nfunction validateQualifiedMaxCountProperty($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $qualifiedMaxCount, $currentShape) {\n\tvar c = validateQualifiedHelper($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $currentShape);\n\treturn c <= Number($qualifiedMaxCount.lex);\n}\n\nfunction validateQualifiedMinCountProperty($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $qualifiedMinCount, $currentShape) {\n\tvar c = validateQualifiedHelper($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $currentShape);\n\treturn c >= Number($qualifiedMinCount.lex);\n}\n\nfunction validateQualifiedHelper($this, $path, $qualifiedValueShape, $qualifiedValueShapesDisjoint, $currentShape) {\n\tvar siblingShapes = new NodeSet();\n\tif(T(\"true\").equals($qualifiedValueShapesDisjoint)) {\n\t\t$shapes.query().\n\t\t\tmatch(\"?parentShape\", \"sh:property\", $currentShape).\n\t\t\tmatch(\"?parentShape\", \"sh:property\", \"?sibling\").\n\t\t\tmatch(\"?sibling\", \"sh:qualifiedValueShape\", \"?siblingShape\").\n\t\t\tfilter(exprNotEquals(\"?siblingShape\", $qualifiedValueShape)) .\n\t\t\taddAllNodes(\"?siblingShape\", siblingShapes);\n\t}\n\treturn $data.query().\n\t\tpath($this, toRDFQueryPath($path), \"?value\").\n\t\tfilter(function(sol) { \n\t\t\treturn SHACL.nodeConformsToShape(sol.value, $qualifiedValueShape) &&\n\t\t\t\t!validateQualifiedConformsToASibling(sol.value, siblingShapes.toArray()); \n\t\t}).\n\t\tgetCount();\n}\n\nfunction validateQualifiedConformsToASibling(value, siblingShapes) {\n\tfor(var i = 0; i < siblingShapes.length; i++) {\n\t\tif(SHACL.nodeConformsToShape(value, siblingShapes[i])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction validateRootClass($value, $rootClass) {\n\treturn $data.query().path($value, { zeroOrMore: T(\"rdfs:subClassOf\") }, $rootClass).hasSolution();\n}\n\nfunction validateStem($value, $stem) {\n\treturn $value.isURI() && $value.uri.startsWith($stem.lex);\n}\n\nfunction validateSubSetOf($this, $subSetOf, $value) {\n\treturn $data.query().match($this, $subSetOf, $value).hasSolution();\n}\n\nfunction validateUniqueLangProperty($this, $uniqueLang, $path) {\n\tif(!T(\"true\").equals($uniqueLang)) {\n\t\treturn;\n\t}\n\tvar map = {};\n\t$data.query().path($this, toRDFQueryPath($path), \"?value\").forEach(function(sol) {\n\t\tvar lang = sol.value.language;\n\t\tif(lang && lang != \"\") {\n\t\t\tvar old = map[lang];\n\t\t\tif(!old) {\n\t\t\t\tmap[lang] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[lang] = old + 1;\n\t\t\t}\n\t\t}\n\t})\n\tvar results = [];\n\tfor(var lang in map) {\n\t\tif(map.hasOwnProperty(lang)) {\n\t\t\tvar count = map[lang];\n\t\t\tif(count > 1) {\n\t\t\t\tresults.push(\"Language \\\"\" + lang + \"\\\" has been used by \" + count + \" values\");\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n}\n\nfunction validateXone($value, $xone) {\n\tvar shapes = new RDFQueryUtil($shapes).rdfListToArray($xone);\n\tvar count = 0;\n\tfor(var i = 0; i < shapes.length; i++) {\n\t\tif(SHACL.nodeConformsToShape($value, shapes[i])) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count == 1;\n}\n\n\n// DASH functions -------------------------------------------------------------\n\n// dash:toString\nfunction dash_toString($arg) {\n\tif($arg.isLiteral()) {\n\t\treturn NodeFactory.literal($arg.lex, T(\"xsd:string\"));\n\t}\n\telse if($arg.isURI()) {\n\t\treturn NodeFactory.literal($arg.uri, T(\"xsd:string\"));\n\t}\n\telse {\n\t\treturn null;\n\t}\n}\n\n\n// DASH targets ---------------------------------------------------------------\n\n// dash:AllObjectsTarget\nfunction dash_allObjects() {\n\treturn $data.query().match(null, null, \"?object\").getNodeSet(\"?object\").toArray();\n}\n\n// dash:AllSubjectsTarget\nfunction dash_allSubjects() {\n\treturn $data.query().match(\"?subject\", null, null).getNodeSet(\"?subject\").toArray();\n}\n\n\n// Utilities ------------------------------------------------------------------\n\nfunction toRDFQueryPath(shPath) {\n    if (shPath.termType === \"Collection\") {\n        var paths = new RDFQueryUtil($shapes).rdfListToArray(shPath);\n        var result = [];\n        for (var i = 0; i < paths.length; i++) {\n            result.push(toRDFQueryPath(paths[i]));\n        }\n        return result;\n    }\n\tif(shPath.isURI()) {\n\t\treturn shPath;\n\t}\n\telse if(shPath.isBlankNode()) {\n\t\tvar util = new RDFQueryUtil($shapes);\n\t\tif($shapes.query().getObject(shPath, \"rdf:first\")) {\n\t\t\tvar paths = util.rdfListToArray(shPath);\n\t\t\tvar result = [];\n\t\t\tfor(var i = 0; i < paths.length; i++) {\n\t\t\t\tresult.push(toRDFQueryPath(paths[i]));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tvar alternativePath = $shapes.query().getObject(shPath, \"sh:alternativePath\");\n\t\tif(alternativePath) {\n\t\t\tvar paths = util.rdfListToArray(alternativePath);\n\t\t\tvar result = [];\n\t\t\tfor(var i = 0; i < paths.length; i++) {\n\t\t\t\tresult.push(toRDFQueryPath(paths[i]));\n\t\t\t}\n\t\t\treturn { or : result };\n\t\t}\n\t\tvar zeroOrMorePath = $shapes.query().getObject(shPath, \"sh:zeroOrMorePath\");\n\t\tif(zeroOrMorePath) {\n\t\t\treturn { zeroOrMore : toRDFQueryPath(zeroOrMorePath) };\n\t\t}\n\t\tvar oneOrMorePath = $shapes.query().getObject(shPath, \"sh:oneOrMorePath\");\n\t\tif(oneOrMorePath) {\n\t\t\treturn { oneOrMore : toRDFQueryPath(oneOrMorePath) };\n\t\t}\n\t\tvar zeroOrOnePath = $shapes.query().getObject(shPath, \"sh:zeroOrOnePath\");\n\t\tif(zeroOrOnePath) {\n\t\t\treturn { zeroOrOne : toRDFQueryPath(zeroOrOnePath) };\n\t\t}\n\t\tvar inversePath = $shapes.query().getObject(shPath, \"sh:inversePath\");\n\t\tif(inversePath) {\n\t\t\treturn { inverse : toRDFQueryPath(inversePath) };\n\t\t}\n\t}\n\tthrow \"Unsupported SHACL path \" + shPath;\n\t// TODO: implement conforming to AbstractQuery.path syntax\n\treturn shPath;\n}\n\n\n// Private helper functions\n\n//TODO: Support more datatypes\nfunction isValidForDatatype(lex, datatype) {\n\tif(XSDIntegerTypes.contains(datatype)) {\n\t\tvar r = parseInt(lex);\n\t\treturn !isNaN(r);\n\t}\n\telse if(XSDDecimalTypes.contains(datatype)) {\n\t\tvar r = parseFloat(lex);\n\t\treturn !isNan(r);\n\t}\n\telse if (datatype.value === \"http://www.w3.org/2001/XMLSchema#boolean\") {\n        return lex !== \"true\" && lex !== \"false\";\n    }\n\telse {\n\t\treturn true;\n\t}\n}\n\nfunction RDFQueryUtil($source) {\n\tthis.source = $source;\n}\n\nRDFQueryUtil.prototype.getInstancesOf = function($class) {\n\tvar set = new NodeSet();\n\tvar classes = this.getSubClassesOf($class);\n\tclasses.add($class);\n\tvar car = classes.toArray();\n\tfor(var i = 0; i < car.length; i++) {\n\t\tset.addAll(RDFQuery(this.source).match(\"?instance\", \"rdf:type\", car[i]).getNodeArray(\"?instance\"));\n\t}\n\treturn set;\n}\n\nRDFQueryUtil.prototype.getObject = function($subject, $predicate) {\n\tif(!$subject) {\n\t\tthrow \"Missing subject\";\n\t}\n\tif(!$predicate) {\n\t\tthrow \"Missing predicate\";\n\t}\n\treturn RDFQuery(this.source).match($subject, $predicate, \"?object\").getNode(\"?object\");\n}\n\nRDFQueryUtil.prototype.getSubClassesOf = function($class) {\n\tvar set = new NodeSet();\n\tthis.walkSubjects(set, $class, T(\"rdfs:subClassOf\"));\n\treturn set;\n}\n\nRDFQueryUtil.prototype.isInstanceOf = function($instance, $class) {\n\tvar classes = this.getSubClassesOf($class);\n\tvar types = $data.query().match($instance, \"rdf:type\", \"?type\");\n\tfor(var n = types.nextSolution(); n; n = types.nextSolution()) {\n\t\tif(n.type.equals($class) || classes.contains(n.type)) {\n\t\t\ttypes.close();\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nRDFQueryUtil.prototype.rdfListToArray = function($rdfList) {\n    if ($rdfList.elements != null) {\n        return $rdfList.elements;\n    } else {\n        var array = [];\n        while (!T(\"rdf:nil\").equals($rdfList)) {\n            array.push(this.getObject($rdfList, T(\"rdf:first\")));\n            $rdfList = this.getObject($rdfList, T(\"rdf:rest\"));\n        }\n        return array;\n    }\n}\n\nRDFQueryUtil.prototype.walkObjects = function($results, $subject, $predicate) {\n\tvar it = this.source.find($subject, $predicate, null);\n\tfor(var n = it.next(); n; n = it.next()) {\n\t\tif(!$results.contains(n.object)) {\n\t\t\t$results.add(n.object);\n\t\t\tthis.walkObjects($results, n.object, $predicate);\n\t\t}\n\t}\n}\n\nRDFQueryUtil.prototype.walkSubjects = function($results, $object, $predicate) {\n\tvar it = this.source.find(null, $predicate, $object);\n\tfor(var n = it.next(); n; n = it.next()) {\n\t\tif(!$results.contains(n.subject)) {\n\t\t\t$results.add(n.subject);\n\t\t\tthis.walkSubjects($results, n.subject, $predicate);\n\t\t}\n\t}\n}\n","http://datashapes.org/js/rdfquery.js":"// rdfquery.js\n// A simple RDF query library for JavaScript\n//\n// Contact: Holger Knublauch, TopQuadrant, Inc. (holger@topquadrant.com)\n//\n// The basic idea is that the function RDFQuery produces an initial\n// Query object, which starts with a single \"empty\" solution.\n// Each query object has a function nextSolution() producing an iteration\n// of variable bindings (\"volcano style\").\n// Each query object can be refined with subsequent calls to other\n// functions, producing new queries.\n// Invoking nextSolution on a query will pull solutions from its\n// predecessors in a chain of query objects.\n// The solution objects are plain JavaScript objects providing a\n// mapping from variable names to RDF Term objects.\n// Unless a query has been walked to exhaustion, .close() must be called.\n//\n// Finally, terminal functions such as .getNode() and .getArray() can be used\n// to produce individual values.  All terminal functions close the query.\n//\n// RDF Term/Node objects are expected to follow the contracts from the\n// RDF Representation Task Force's interface specification:\n// https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\n//\n// In order to bootstrap all this, graph objects need to implement a\n// function .find(s, p, o) where each parameter is either an RDF term or null\n// producing an iterator object with a .next() function that produces RDF triples\n// (with attributes subject, predicate, object) or null when done.\n//\n// (Note I am not particularly a JavaScript guru so the modularization of this\n// script may be improved to hide private members from public API etc).\n\n/* \nExample:\n\n\tvar result = $data.query().\n\t\tmatch(\"owl:Class\", \"rdfs:label\", \"?label\").\n\t\tmatch(\"?otherClass\", \"rdfs:label\", \"?label\").\n\t\tfilter(function(sol) { return !T(\"owl:Class\").equals(sol.otherClass) }).\n\t\tgetNode(\"?otherClass\");\n\t\t\nEquivalent SPARQL:\n\t\tSELECT ?otherClass\n\t\tWHERE {\n\t\t\towl:Class rdfs:label ?label .\n\t\t\t?otherClass rdfs:label ?label .\n\t\t\tFILTER (owl:Class != ?otherClass) .\n\t\t} LIMIT 1\n*/\n\nif(!this[\"TermFactory\"]) {   \n\t// In some environments such as Nashorn this may already have a value\n\t// In TopBraid this is redirecting to native Jena calls\n\tTermFactory = {\n\t\t\t\n\t\timpl : null,   // This needs to be connected to an API such as $rdf\t\n\t\t\t\n\t\t// Globally registered prefixes for TTL short cuts\n\t\tnamespaces : {},\t\n\t\t\n\t\t/**\n\t\t * Registers a new namespace prefix for global TTL short cuts (qnames).\n\t\t * @param prefix  the prefix to add\n\t\t * @param namespace  the namespace to add for the prefix\n\t\t */\n\t\tregisterNamespace : function(prefix, namespace) {\n\t\t\tif(this.namespaces.prefix) {\n\t\t\t\tthrow \"Prefix \" + prefix + \" already registered\"\n\t\t\t}\n\t\t\tthis.namespaces[prefix] = namespace;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces an RDF term from a TTL string representation.\n\t\t * Also uses the registered prefixes.\n\t\t * @param str  a string, e.g. \"owl:Thing\" or \"true\" or '\"Hello\"@en'.\n\t\t * @return an RDF term\n\t\t */\n\t\tterm : function(str) {\n\t\t\t// TODO: this implementation currently only supports booleans and qnames - better overload to rdflib.js\n\t\t\tif(\"true\" === str || \"false\" === str) {\n\t\t\t\treturn this.literal(str, T(\"xsd:boolean\"))\n\t\t\t}\n\t\t\tvar col = str.indexOf(\":\")\n\t\t\tif(col < 0) {\n\t\t\t\tthrow \"Expected qname with a ':', but found: \" + str;\n\t\t\t}\n\t\t\tvar ns = this.namespaces[str.substring(0, col)];\n\t\t\tif(!ns) {\n\t\t\t\tthrow \"Unregistered prefix \" + str.substring(0, col) + \" of node \" + str;\n\t\t\t}\n\t\t\treturn this.namedNode(ns + str.substring(col + 1));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces a new blank node.\n\t\t * @param id  an optional ID for the node\n\t\t */\n\t\tblankNode : function(id) {\n\t\t\treturn this.impl.blankNode(id);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces a new literal.  For example .literal(\"42\", T(\"xsd:integer\")).\n\t\t * @param lex  the lexical form, e.g. \"42\"\n\t\t * @param langOrDatatype  either a language string or a URI node with the datatype\n\t\t */\n\t\tliteral : function(lex, langOrDatatype) {\n\t\t\treturn this.impl.literal(lex, langOrDatatype)\n\t\t},\n\t\t\n\t\t// This function is basically left for Task Force compatibility, but the preferred function is uri()\n\t\tnamedNode : function(uri) {\n\t\t\treturn this.impl.namedNode(uri)\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces a new URI node.\n\t\t * @param uri  the URI of the node\n\t\t */\n\t\turi : function(uri) {\n\t\t\treturn namedNode(uri);\n\t\t}\n\t}\n}\n\n// Install NodeFactory as an alias - unsure which name is best long term:\n// The official name in RDF is \"term\", while \"node\" is more commonly understood.\n// Oficially, a \"node\" must be in a graph though, while \"terms\" are independent.\nvar NodeFactory = TermFactory;\n\n\nNodeFactory.registerNamespace(\"dc\", \"http://purl.org/dc/elements/1.1/\")\nNodeFactory.registerNamespace(\"dcterms\", \"http://purl.org/dc/terms/\")\nNodeFactory.registerNamespace(\"rdf\", \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\")\nNodeFactory.registerNamespace(\"rdfs\", \"http://www.w3.org/2000/01/rdf-schema#\")\nNodeFactory.registerNamespace(\"schema\", \"http://schema.org/\")\nNodeFactory.registerNamespace(\"sh\", \"http://www.w3.org/ns/shacl#\")\nNodeFactory.registerNamespace(\"skos\", \"http://www.w3.org/2004/02/skos/core#\")\nNodeFactory.registerNamespace(\"owl\", \"http://www.w3.org/2002/07/owl#\")\nNodeFactory.registerNamespace(\"xsd\", \"http://www.w3.org/2001/XMLSchema#\")\n\n// Candidates:\n// NodeFactory.registerNamespace(\"prov\", \"http://www.w3.org/ns/prov#\");\n\n/**\n * A shortcut for NodeFactory.term(str) - turns a TTL string representation of an RDF\n * term into a proper RDF term.\n * This will also use the globally registered namespace prefixes.\n * @param str  the string representation, e.g. \"owl:Thing\"\n * @returns\n */\nfunction T(str) {\n\treturn NodeFactory.term(str)\n}\n\n\n/**\n * Creates a query object for a given graph and optional initial solution.\n * The resulting object can be further refined using the functions on\n * AbstractQuery such as <code>match()</code> and <code>filter()</code>.\n * Functions such as <code>nextSolution()</code> can be used to get the actual results.\n * @param graph  the graph to query\n * @param initialSolution  the initial solutions or null for none\n * @returns a query object\n */\nfunction RDFQuery(graph, initialSolution) {\n\treturn new StartQuery(graph, initialSolution ? initialSolution : []);\n}\n\n\n// class AbstractQuery\n\nfunction AbstractQuery() {\n}\n\n// ----------------------------------------------------------------------------\n// Query constructor functions, can be chained together\n// ----------------------------------------------------------------------------\n\n/**\n * Creates a new query that adds a binding for a given variable into\n * each solution produced by the input query.\n * @param varName  the name of the variable to bind, starting with \"?\"\n * @param bindFunction  a function that takes a solution object\n *                      and returns a node or null based on it.\n */\nAbstractQuery.prototype.bind = function(varName, bindFunction) {\n\treturn new BindQuery(this, varName, bindFunction);\n}\n\n/**\n * Creates a new query that filters the solutions produced by this.\n * @param filterFunction  a function that takes a solution object\n *                        and returns true iff that solution is valid\n */\nAbstractQuery.prototype.filter = function(filterFunction) {\n\treturn new FilterQuery(this, filterFunction);\n}\n\n/**\n * Creates a new query that only allows the first n solutions through.\n * @param limit  the maximum number of results to allow\n */\nAbstractQuery.prototype.limit = function(limit) {\n\treturn new LimitQuery(this, limit);\n}\n\n/**\n * Creates a new query doing a triple match.\n * In each subject, predicate, object position, the values can either be\n * an RDF term object or null (wildcard) or a string.\n * If it is a string it may either be a variable (starting with \"?\")\n * or the TTL representation of an RDF term using the T() function.\n * @param s  the match subject\n * @param p  the match predicate\n * @param o  the match object\n */\nAbstractQuery.prototype.match = function(s, p, o) {\n\treturn new MatchQuery(this, s, p, o);\n}\n\n/**\n * Creates a new query that sorts all input solutions by the bindings\n * for a given variable.\n * @param varName  the name of the variable to sort by, starting with \"?\"\n */\nAbstractQuery.prototype.orderBy = function(varName) {\n\treturn new OrderByQuery(this, varName);\n}\n\n/**\n * Creates a new query doing a match where the predicate may be a RDF Path object.\n * Note: This is currently not using lazy evaluation and will always walk all matches.\n * Path syntax:\n * - PredicatePaths: NamedNode\n * - SequencePaths: [path1, path2]\n * - AlternativePaths: { or : [ path1, path2 ] }\n * - InversePaths: { inverse : path }   LIMITATION: Only supports NamedNodes for path here\n * - ZeroOrMorePaths: { zeroOrMore : path }\n * - OneOrMorePaths: { oneOrMore : path }\n * - ZeroOrOnePaths: { zeroOrOne : path }\n * @param s  the match subject or a variable name (string) - must have a value\n *           at execution time!\n * @param path  the match path object (e.g. a NamedNode for a simple predicate hop)\n * @param o  the match object or a variable name (string)\n */\nAbstractQuery.prototype.path = function(s, path, o) {\n\tif(path && path.value && path.isURI()) {\n\t\treturn new MatchQuery(this, s, path, o);\n\t}\n\telse {\n\t\treturn new PathQuery(this, s, path, o);\n\t}\n}\n\n// TODO: add other SPARQL-like query types\n//       - .distinct()\n//       - .union(otherQuery)\n\n\n// ----------------------------------------------------------------------------\n// Terminal functions - convenience functions to get values.\n// All these functions close the solution iterators.\n// ----------------------------------------------------------------------------\n\n/**\n * Adds all nodes produced by a given solution variable into a set.\n * The set must have an add(node) function.\n * @param varName  the name of the variable, starting with \"?\"\n * @param set  the set to add to\n */\nAbstractQuery.prototype.addAllNodes = function(varName, set) {\n\tvar attrName = var2Attr(varName);\n\tfor(var sol = this.nextSolution(); sol; sol = this.nextSolution()) {\n\t\tvar node = sol[attrName];\n\t\tif(node) {\n\t\t\tset.add(node);\n\t\t}\n\t}\n}\n\n/**\n * Produces an array of triple objects where each triple object has properties\n * subject, predicate and object derived from the provided template values.\n * Each of these templates can be either a variable name (starting with '?'),\n * an RDF term string (such as \"rdfs:label\") or a JavaScript node object.\n * @param subject  the subject node\n * @param predicate  the predicate node\n * @param object  the object node\n */\nAbstractQuery.prototype.construct = function(subject, predicate, object) {\n\tvar results = [];\n\tfor(var sol = this.nextSolution(); sol; sol = this.nextSolution()) {\n\t\tvar s = null;\n\t\tif(typeof subject === 'string') {\n\t\t\tif(subject.indexOf('?') == 0) {\n\t\t\t\ts = sol[var2Attr(subject)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts = T(subject);\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\ts = subject;\n\t\t}\n\t\tvar p = null;\n\t\tif(typeof predicate === 'string') {\n\t\t\tif(predicate.indexOf('?') == 0) {\n\t\t\t\tp = sol[var2Attr(predicate)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp = T(predicate);\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\tp = predicate;\n\t\t}\n\n\t\tvar o = null;\n\t\tif(typeof object === 'string') {\n\t\t\tif(object.indexOf('?') == 0) {\n\t\t\t\to = sol[var2Attr(object)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\to = T(object);\n\t\t\t}\n\t\t} \n\t\telse {\n\t\t\to = object;\n\t\t}\n\n\t\tif(s && p && o) {\n\t\t\tresults.push({ subject: s, predicate: p, object: o});\n\t\t}\n\t}\n\treturn results;\n}\n\n/**\n * Executes a given function for each solution.\n * @param callback  a function that takes a solution as argument\n */\nAbstractQuery.prototype.forEach = function(callback) {\n\tfor(var n = this.nextSolution(); n; n = this.nextSolution()) {\n\t\tcallback(n);\n\t}\n}\n\n/**\n * Executes a given function for each node in a solution set.\n * @param varName  the name of a variable, starting with \"?\"\n * @param callback  a function that takes a node as argument\n */\nAbstractQuery.prototype.forEachNode = function(varName, callback) {\n\tvar attrName = var2Attr(varName);\n\tfor(var sol = this.nextSolution(); sol; sol = this.nextSolution()) {\n\t\tvar node = sol[attrName];\n\t\tif(node) {\n\t\t\tcallback(node);\n\t\t}\n\t}\n}\n\n/**\n * Turns all result solutions into an array.\n * @return an array consisting of solution objects\n */\nAbstractQuery.prototype.getArray = function() {\n\tvar results = [];\n\tfor(var n = this.nextSolution(); n != null; n = this.nextSolution()) {\n\t\tresults.push(n);\n\t}\n\treturn results;\n}\n\n/**\n * Gets the number of (remaining) solutions.\n * @return the count\n */\nAbstractQuery.prototype.getCount = function() {\n\treturn this.getArray().length; // Quick and dirty implementation\n}\n\n/**\n * Gets the next solution and, if that exists, returns the binding for a\n * given variable from that solution.\n * @param varName  the name of the binding to get, starting with \"?\"\n * @return the value of the variable or null or undefined if it doesn't exist\n */\nAbstractQuery.prototype.getNode = function(varName) {\n\tvar s = this.nextSolution();\n\tif(s) {\n\t\tthis.close();\n\t\treturn s[var2Attr(varName)];\n\t}\n\telse {\n\t\treturn null;\n\t}\n}\n\n/**\n * Turns all results into an array of bindings for a given variable.\n * @return an array consisting of RDF node objects\n */\nAbstractQuery.prototype.getNodeArray = function(varName) {\n\tvar results = [];\n\tvar attr = var2Attr(varName);\n\tfor(var n = this.nextSolution(); n != null; n = this.nextSolution()) {\n\t\tresults.push(n[attr]);\n\t}\n\treturn results;\n}\n\n/**\n * Turns all result bindings for a given variable into a set.\n * The set has functions .contains and .toArray. \n * @param varName  the name of the variable, starting with \"?\"\n * @return a set consisting of RDF node objects\n */\nAbstractQuery.prototype.getNodeSet = function(varName) {\n\tvar results = new NodeSet();\n\tvar attr = var2Attr(varName);\n\tfor(var n = this.nextSolution(); n != null; n = this.nextSolution()) {\n\t\tresults.add(n[attr]);\n\t}\n\treturn results;\n}\n\n/**\n * Queries the underlying graph for the object of a subject/predicate combination,\n * where either subject or predicate can be a variable which is substituted with\n * a value from the next input solution.\n * Note that even if there are multiple solutions it will just return the \"first\"\n * one and since the order of triples in RDF is undefined this may lead to random results.\n * Unbound values produce errors.\n * @param subject  an RDF term or a variable (starting with \"?\") or a TTL representation\n * @param predicate  an RDF term or a variable (starting with \"?\") or a TTL representation\n * @return the object of the \"first\" triple matching the subject/predicate combination\n */\nAbstractQuery.prototype.getObject = function(subject, predicate) {\n\tvar sol = this.nextSolution();\n\tif(sol) {\n\t\tthis.close();\n\t\tvar s;\n\t\tif(typeof subject === 'string') {\n\t\t\tif(subject.indexOf('?') == 0) {\n\t\t\t\ts = sol[var2Attr(subject)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts = T(subject);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ts = subject;\n\t\t}\n\t\tif(!s) {\n\t\t\tthrow \"getObject() called with null subject\";\n\t\t}\n\t\tvar p;\n\t\tif(typeof predicate === 'string') {\n\t\t\tif(predicate.indexOf('?') == 0) {\n\t\t\t\tp = sol[var2Attr(predicate)];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp = T(predicate);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tp = predicate;\n\t\t}\n\t\tif(!p) {\n\t\t\tthrow \"getObject() called with null predicate\";\n\t\t}\n\t\t\n\t\tvar it = this.source.find(s, p, null);\n\t\tvar triple = it.next();\n\t\tif(triple) {\n\t\t\tit.close();\n\t\t\treturn triple.object;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Tests if there is any solution and closes the query.\n * @return true if there is another solution\n */\nAbstractQuery.prototype.hasSolution = function() {\n\tif(this.nextSolution()) {\n\t\tthis.close();\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\n\n\n// ----------------------------------------------------------------------------\n// Expression functions - may be used in filter and bind queries\n// ----------------------------------------------------------------------------\n\n/**\n * Creates a function that takes a solution and compares a given node with\n * the binding of a given variable from that solution.\n * @param varName  the name of the variable (starting with \"?\")\n * @param node  the node to compare with\n * @returns true if the solution's variable equals the node\n */\nfunction exprEquals(varName, node) {\n\treturn function(sol) {\n\t\treturn node.equals(sol[var2Attr(varName)]);\n\t}\n}\n\n/**\n * Creates a function that takes a solution and compares a given node with\n * the binding of a given variable from that solution.\n * @param varName  the name of the variable (starting with \"?\")\n * @param node  the node to compare with\n * @returns true if the solution's variable does not equal the node\n */\nfunction exprNotEquals(varName, node) {\n\treturn function(sol) {\n\t\treturn !node.equals(sol[var2Attr(varName)]);\n\t}\n}\n\n\n// ----------------------------------------------------------------------------\n// END OF PUBLIC API ----------------------------------------------------------\n// ----------------------------------------------------------------------------\n\n\n// class BindQuery\n// Takes all input solutions but adds a value for a given variable so that\n// the value is computed by a given function based on the current solution.\n// It is illegal to use a variable that already has a value from the input.\n\nfunction BindQuery(input, varName, bindFunction) {\n\tthis.attr = var2Attr(varName);\n\tthis.source = input.source;\n\tthis.input = input;\n\tthis.bindFunction = bindFunction;\n}\n\nBindQuery.prototype = Object.create(AbstractQuery.prototype);\n\nBindQuery.prototype.close = function() {\n\tthis.input.close();\n}\n\n// Pulls the next result from the input Query and passes it into \n// the given bind function to add a new node\nBindQuery.prototype.nextSolution = function() {\n\tvar result = this.input.nextSolution();\n\tif(result == null) {\n\t\treturn null;\n\t}\n\telse {\n\t\tvar newNode = this.bindFunction(result);\n\t\tif(newNode) {\n\t\t\tresult[this.attr] = newNode;\n\t\t}\n\t\treturn result;\n\t}\n}\n\n\n// class FilterQuery\n// Filters the incoming solutions, only letting through those where\n// filterFunction(solution) returns true\n\nfunction FilterQuery(input, filterFunction) {\n\tthis.source = input.source;\n\tthis.input = input;\n\tthis.filterFunction = filterFunction;\n}\n\nFilterQuery.prototype = Object.create(AbstractQuery.prototype);\n\nFilterQuery.prototype.close = function() {\n\tthis.input.close();\n}\n\n// Pulls the next result from the input Query and passes it into \n// the given filter function\nFilterQuery.prototype.nextSolution = function() {\n\tfor(;;) {\n\t\tvar result = this.input.nextSolution();\n\t\tif(result == null) {\n\t\t\treturn null;\n\t\t}\n\t\telse if(this.filterFunction(result) === true) {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\n\n// class LimitQuery\n// Only allows the first n values of the input query through\n\nfunction LimitQuery(input, limit) {\n\tthis.source = input.source;\n\tthis.input = input;\n\tthis.limit = limit;\n}\n\nLimitQuery.prototype = Object.create(AbstractQuery.prototype);\n\nLimitQuery.prototype.close = function() {\n\tthis.input.close();\n}\n\n// Pulls the next result from the input Query unless the number\n// of previous calls has exceeded the given limit\nLimitQuery.prototype.nextSolution = function() {\n\tif(this.limit > 0) {\n\t\tthis.limit--;\n\t\treturn this.input.nextSolution();\n\t}\n\telse {\n\t\tthis.input.close();\n\t\treturn null;\n\t}\n}\n\n\n// class MatchQuery\n// Joins the solutions from the input Query with triple matches against\n// the current input graph.\n\nfunction MatchQuery(input, s, p, o) {\n\tthis.source = input.source;\n\tthis.input = input;\n\tif(typeof s === 'string') {\n\t\tif(s.indexOf('?') == 0) {\n\t\t\tthis.sv = var2Attr(s);\n\t\t}\n\t\telse {\n\t\t\tthis.s = T(s);\n\t\t}\n\t} \n\telse {\n\t\tthis.s = s;\n\t}\n\tif(typeof p === 'string') {\n\t\tif(p.indexOf('?') == 0) {\n\t\t\tthis.pv = var2Attr(p);\n\t\t}\n\t\telse {\n\t\t\tthis.p = T(p);\n\t\t}\n\t} \n\telse {\n\t\tthis.p = p;\n\t}\n\tif(typeof o === 'string') {\n\t\tif(o.indexOf('?') == 0) {\n\t\t\tthis.ov = var2Attr(o);\n\t\t}\n\t\telse {\n\t\t\tthis.o = T(o);\n\t\t}\n\t} \n\telse {\n\t\tthis.o = o;\n\t}\n}\n\nMatchQuery.prototype = Object.create(AbstractQuery.prototype);\n\nMatchQuery.prototype.close = function() {\n\tthis.input.close();\n\tif(this.ownIterator) {\n\t\tthis.ownIterator.close();\n\t}\n}\n\n// This pulls the first solution from the input Query and uses it to\n// create an \"ownIterator\" which applies the input solution to those\n// specified by s, p, o.\n// Once this \"ownIterator\" has been exhausted, it moves to the next\n// solution from the input Query, and so on.\n// At each step, it produces the union of the input solutions plus the\n// own solutions.\nMatchQuery.prototype.nextSolution = function() {\n\n\tvar oit = this.ownIterator;\n\tif(oit) {\n\t\tvar n = oit.next();\n\t\tif(n != null) {\n\t\t\tvar result = createSolution(this.inputSolution);\n\t\t\tif(this.sv) {\n\t\t\t\tresult[this.sv] = n.subject;\n\t\t\t}\n\t\t\tif(this.pv) {\n\t\t\t\tresult[this.pv] = n.predicate;\n\t\t\t}\n\t\t\tif(this.ov) {\n\t\t\t\tresult[this.ov] = n.object;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tdelete this.ownIterator; // Mark as exhausted\n\t\t}\n\t}\n\t\n\t// Pull from input\n\tthis.inputSolution = this.input.nextSolution();\n\tif(this.inputSolution) {\n\t\tvar sm = this.sv ? this.inputSolution[this.sv] : this.s;\n\t\tvar pm = this.pv ? this.inputSolution[this.pv] : this.p;\n\t\tvar om = this.ov ? this.inputSolution[this.ov] : this.o;\n\t\tthis.ownIterator = this.source.find(sm, pm, om);\n\t\treturn this.nextSolution();\n\t}\n\telse {\n\t\treturn null;\n\t}\n}\n\n\n// class OrderByQuery\n// Sorts all solutions from the input stream by a given variable\n\nfunction OrderByQuery(input, varName) {\n\tthis.input = input;\n\tthis.source = input.source;\n\tthis.attrName = var2Attr(varName);\n}\n\nOrderByQuery.prototype = Object.create(AbstractQuery.prototype);\n\nOrderByQuery.prototype.close = function() {\n\tthis.input.close();\n}\n\nOrderByQuery.prototype.nextSolution = function() {\n\tif(!this.solutions) {\n\t\tthis.solutions = this.input.getArray();\n\t\tvar attrName = this.attrName;\n\t\tthis.solutions.sort(function(s1, s2) {\n\t\t\t\treturn compareTerms(s1[attrName], s2[attrName]);\n\t\t\t});\n\t\tthis.index = 0;\n\t}\n\tif(this.index < this.solutions.length) {\n\t\treturn this.solutions[this.index++];\n\t}\n\telse {\n\t\treturn null;\n\t}\n}\n\n\n// class PathQuery\n// Expects subject and path to be bound and produces all bindings\n// for the object variable or matches that by evaluating the given path\n\nfunction PathQuery(input, subject, path, object) {\n\tthis.input = input;\n\tthis.source = input.source;\n\tif(typeof subject === 'string' && subject.indexOf(\"?\") == 0) {\n\t\tthis.subjectAttr = var2Attr(subject);\n\t}\n\telse {\n\t\tthis.subject = subject;\n\t}\n\tif(path == null) {\n\t\tthrow \"Path cannot be unbound\";\n\t}\n\tif(typeof path === 'string') {\n\t\tthis.path_ = T(path);\n\t}\n\telse {\n\t\tthis.path_ = path;\n\t}\n\tif(typeof object === 'string' && object.indexOf(\"?\") == 0) {\n\t\tthis.objectAttr = var2Attr(object);\n\t}\n\telse {\n\t\tthis.object = object;\n\t}\n}\n\nPathQuery.prototype = Object.create(AbstractQuery.prototype);\n\nPathQuery.prototype.close = function() {\n\tthis.input.close();\n}\n\nPathQuery.prototype.nextSolution = function() {\n\n\tvar r = this.pathResults;\n\tif(r) {\n\t\tvar n = r[this.pathIndex++];\n\t\tvar result = createSolution(this.inputSolution);\n\t\tif(this.objectAttr) {\n\t\t\tresult[this.objectAttr] = n;\n\t\t}\n\t\tif(this.pathIndex == r.length) {\n\t\t\tdelete this.pathResults; // Mark as exhausted\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t// Pull from input\n\tthis.inputSolution = this.input.nextSolution();\n\tif(this.inputSolution) {\n\t\tvar sm = this.subjectAttr ? this.inputSolution[this.subjectAttr] : this.subject;\n\t\tif(sm == null) {\n\t\t\tthrow \"Path cannot have unbound subject\";\n\t\t}\n\t\tvar om = this.objectAttr ? this.inputSolution[this.objectAttr] : this.object;\n\t\tvar pathResultsSet = new NodeSet();\n\t\taddPathValues(this.source, sm, this.path_, pathResultsSet);\n\t\tthis.pathResults = pathResultsSet.toArray();\n\t\tif(this.pathResults.length == 0) {\n\t\t\tdelete this.pathResults;\n\t\t}\n\t\telse if(om) {\n\t\t\tdelete this.pathResults;\n\t\t\tif(pathResultsSet.contains(om)) {\n\t\t\t\treturn this.inputSolution;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.pathIndex = 0;\n\t\t}\n\t\treturn this.nextSolution();\n\t}\n\telse {\n\t\treturn null;\n\t}\n}\n\n\n// class StartQuery\n// This simply produces a single result: the initial solution\n\nfunction StartQuery(source, initialSolution) {\n\tthis.source = source;\n\tthis.solution = initialSolution;\n}\n\nStartQuery.prototype = Object.create(AbstractQuery.prototype);\n\nStartQuery.prototype.close = function() {\n}\n\nStartQuery.prototype.nextSolution = function() {\n\tif(this.solution) {\n\t\tvar b = this.solution;\n\t\tdelete this.solution;\n\t\treturn b;\n\t}\n\telse {\n\t\treturn null;\n\t}\n}\n\n\n// Helper functions\n\nfunction createSolution(base) {\n\tvar result = {};\n\tfor(var attr in base) {\n\t\tif(base.hasOwnProperty(attr)) {\n\t\t\tresult[attr] = base[attr];\n\t\t}\n\t}\n\treturn result;\n}\n\n\nfunction compareTerms(t1, t2) {\n\tif(!t1) {\n\t\treturn !t2 ? 0 : 1;\n\t}\n\telse if(!t2) {\n\t\treturn -1;\n\t}\n\tvar bt = t1.termType.localeCompare(t2.termType);\n\tif(bt != 0) {\n\t\treturn bt;\n\t}\n\telse {\n\t\t// TODO: Does not handle numeric or date comparison\n\t\tvar bv = t1.value.localeCompare(t2.value);\n\t\tif(bv != 0) {\n\t\t\treturn bv;\n\t\t}\n\t\telse {\n\t\t\tif(t1.isLiteral()) {\n\t\t\t\tvar bd = t1.datatype.uri.localeCompare(t2.datatype.uri);\n\t\t\t\tif(bd != 0) {\n\t\t\t\t\treturn bd;\n\t\t\t\t}\n\t\t\t\telse if(T(\"rdf:langString\").equals(t1.datatype)) {\n\t\t\t\t\treturn t1.language.localeCompare(t2.language);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction getLocalName(uri) {\n\t// TODO: This is not the 100% correct local name algorithm\n\tvar index = uri.lastIndexOf(\"#\"); \n\tif(index < 0) {\n\t\tindex = uri.lastIndexOf(\"/\");\n\t}\n\tif(index < 0) {\n\t\tthrow \"Cannot get local name of \" + uri;\n\t}\n\treturn uri.substring(index + 1);\n}\n\n\n// class NodeSet\n// (a super-primitive implementation for now!)\n\nfunction NodeSet() {\n\tthis.values = [];\n}\n\nNodeSet.prototype.add = function(node) {\n\tif(!this.contains(node)) {\n\t\tthis.values.push(node);\n\t}\n}\n\nNodeSet.prototype.addAll = function(nodes) {\n\tfor(var i = 0; i < nodes.length; i++) {\n\t\tthis.add(nodes[i]);\n\t}\n}\n\nNodeSet.prototype.contains = function(node) {\n\tfor(var i = 0; i < this.values.length; i++) {\n\t\tif(this.values[i].equals(node)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nNodeSet.prototype.forEach = function(callback) {\n\tfor(var i = 0; i < this.values.length; i++) {\n\t\tcallback(this.values[i]);\n\t}\n}\n\nNodeSet.prototype.size = function() {\n\treturn this.values.length;\n}\n\nNodeSet.prototype.toArray = function() {\n\treturn this.values;\n}\n\nNodeSet.prototype.toString = function() {\n\tvar str = \"NodeSet(\" + this.size() + \"): [\";\n\tvar arr = this.toArray();\n\tfor(var i = 0; i < arr.length; i++) {\n\t\tif(i > 0) {\n\t\t\tstr += \", \";\n\t\t}\n\t\tstr += arr[i];\n\t}\n\treturn str + \"]\";\n}\n\n\nfunction var2Attr(varName) {\n\tif(!varName.indexOf(\"?\") == 0) {\n\t\tthrow \"Variable name must start with ?\";\n\t}\n\tif(varName.length == 1) {\n\t\tthrow \"Variable name too short\";\n\t}\n\treturn varName.substring(1);\n}\n\n\n\n// Simple Path syntax implementation:\n// Adds all matches for a given subject and path combination into a given NodeSet.\n// This should really be doing lazy evaluation and only up to the point\n// where the match object is found.\nfunction addPathValues(graph, subject, path, set) {\n\tif(path.uri) {\n\t\tset.addAll(RDFQuery(graph).match(subject, path, \"?object\").getNodeArray(\"?object\"));\n\t}\n\telse if(Array.isArray(path)) {\n\t\tvar s = new NodeSet();\n\t\ts.add(subject);\n\t\tfor(var i = 0; i < path.length; i++) {\n\t\t\tvar a = s.toArray();\n\t\t\ts = new NodeSet();\n\t\t\tfor(var j = 0; j < a.length; j++) {\n\t\t\t\taddPathValues(graph, a[j], path[i], s);\n\t\t\t}\n\t\t}\n\t\tset.addAll(s.toArray());\n\t}\n\telse if(path.or) {\n\t\tfor(var i = 0; i < path.or.length; i++) {\n\t\t\taddPathValues(graph, subject, path.or[i], set);\n\t\t}\n\t}\n\telse if(path.inverse) {\n\t\tif(path.inverse.isURI()) {\n\t\t\tset.addAll(RDFQuery(graph).match(\"?subject\", path.inverse, subject).getNodeArray(\"?subject\"));\n\t\t}\n\t\telse {\n\t\t\tthrow \"Unsupported: Inverse paths only work for named nodes\";\n\t\t}\n\t}\n\telse if(path.zeroOrOne) {\n\t\taddPathValues(graph, subject, path.zeroOrOne, set);\n\t\tset.add(subject);\n\t}\n\telse if(path.zeroOrMore) {\n\t\twalkPath(graph, subject, path.zeroOrMore, set, new NodeSet());\n\t\tset.add(subject);\n\t}\n\telse if(path.oneOrMore) {\n\t\twalkPath(graph, subject, path.oneOrMore, set, new NodeSet());\n\t}\n\telse {\n\t\tthrow \"Unsupported path object: \" + path;\n\t}\n}\n\nfunction walkPath(graph, subject, path, set, visited) {\n\tvisited.add(subject);\n\tvar s = new NodeSet();\n\taddPathValues(graph, subject, path, s);\n\tvar a = s.toArray();\n\tset.addAll(a);\n\tfor(var i = 0; i < a.length; i++) {\n\t\tif(!visited.contains(a[i])) {\n\t\t\twalkPath(graph, a[i], path, set, visited);\n\t\t}\n\t}\n}\n"}